For each of the features in this program, I performed the standard testing ensuring the number of characters didn’t exceed the requirement and ensuring the user input was of the correct variable type. The more advanced testing came from ensuring that the unique ID was indeed unique, and testing the methods I created for the functionality of adding, deleting, and updating array objects. My JUnit tests were effective because my coverage percentage of the program was fairly high as well. This high coverage percentage coupled with the fact that most of the JUnit tests passed tells me that the program was fairly bug free and the functionality was working as it was designed to.

The JUnit tests, when most of them came back as passing, helped to ensure that the code was technically sound, i.e., not bug ridden and was working as expected. If my code was not technically sound, the majority of the JUnit tests would’ve failed, and this simply wasn’t the case. As for efficiency of the code, my biggest strategy here was to simply design the code in such a way that the least amount of code was being written as possible, as well as the least amount of loops written, the most efficient data structure used, and ultimately every effort to speed up the code and make it look as neat and orderly as possible was made. To test this efficiency, I simply combed through the code looking for any way in which I could improve the code, shorten its sequences, and make it run faster.

In project one, I used the testing techniques of unit testing, regression testing, and acceptance testing. Unit tests are used to test specific blocks of code in a software application so that errors and broken functionality can be found and corrected more easily. Regression testing is used to test for any errors or broken functionality that occurs after a change is made to an application. Acceptance testing is used for ensuring the requirements of the application are met. I did not use a multitude of other testing techniques. These absent techniques include security testing and API testing. API testing is used to determine that the application is interacting with and using an API correctly, and security testing is used to ensure security functions are working properly and the application is hardened with security features.

Unit testing is a pretty standard way of testing the functions of an application, therefore, I see almost every project using unit tests as part of their testing protocol. Regression testing is typically used post launch of an application to push bug fix updates and functionality repairs reported by end users. Acceptance testing is used pre-launch of the application to ensure the requirements of the app are satisfied. Like unit testing, I feel as though this is also another pretty standard testing technique used in almost all commercial scenarios. The only scenario I see that acceptance testing wouldn’t be employed is for personal projects where no large userbase is expected to be using the end product. API testing would be used if an API was involved in the program. Banks and other financial institutions come to mind when think about API testing. Lastly, security testing is another standard I see being used in almost every commercial application. It would be pretty rare and certainly irresponsible of a development team to not employ this testing technique on their application before releasing it to the public, and it may even yield legal consequences for not doing so.

This course has shifted my mindset towards programming in that it has made me write my programs with more awareness. What I mean by this is that I now write my code with more energy geared towards avoiding programming mistakes, sloppy unnecessary code, and ultimately avoiding mistakes that will make the testing phase more difficult and time consuming. In other words, although not entirely possible, I now try harder to get the code correct and in an ideal state while I’m writing it versus deciding that I’ll just deal with it later.

I feel as though any programmer that aspires for greatness in their field understands that bias and smugness is not the path aimed toward growth. With this said, it wasn’t difficult to avoid being biased for me. However, I can certainly see how biases of one’s own abilities, ways of doing things, and the code that they produced being a sort of roadblock that’s counterproductive to ensuring a good product is good. The best thing a programmer can do in a situation where they’re testing their own code and their feeling biased is to simply remember that no one is perfect and that they can only get better by admitting to themself that their way is not always the best way and to be open to new ideas for the sake of advancement. If a programmer cannot manage this, the next best move, I’d say, is to have another programmer test their code to avoid such biases.

Staying disciplined and committed to the release of quality software products as a software engineer is important on a grant level. In many cases, a lot of people will be using your product and, with today’s standard in technology, the users of your application will trust that the software is working as intended to the extent of blind trust. Depending on the context and the problem the software is intended to solve or remedy, this blind trust of the userbase could yield massive negative consequences if something were to go wrong in the programming. Take the new industry of self-driving cars for example. If the software of these vehicles isn’t absolutely watertight in its implementation, crashes could occur due to a software fault, error, or bug and people could die. It’s a very serious thing. Therefore, as a programmer and practitioner of quality assurance, I plan to do my best in avoiding these unacceptable software mishaps from occurring by creating sound code and doing a ton of testing until every last bit of incorrect code is weeded out. Then, and only then, will any of my products hit the market (assuming it is actually up to me of course).
